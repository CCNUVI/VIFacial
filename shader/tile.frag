////	Render To Texture post-effect shader//  Original code from Ogre3D sample compositor written in Cg//  Modified by S. James Lee//	support mosain tiling & cloning texture grid (latter one does not really//	need fragment shader computation. app can change tex uv for this => cheaper?)//varying vec4 diffuse, ambient;varying vec3 normal, lightDir;vec3 EdgeColor = vec3(0.8, 0.8, 0.8);uniform float NumTiles;uniform float Threshhold;uniform float scRatio;uniform int tileMode;uniform int obj;uniform float time;uniform sampler2D rttMap;void main(void){	// this shader takes care of two cases	// the first case where rendering object is real head (obj == 0)	// the secon case is RTT	if (obj == 0)	{		vec3 ct,cf;		vec4 texel;		float intensity,at,af;			vec3 n = normalize(normal);		intensity = max( dot(lightDir,n),0.0);					cf = intensity * diffuse.rgb + ambient.rgb;		af = diffuse.a;			texel = texture2D(rttMap, gl_TexCoord[0].st);		ct = texel.rgb;		at = texel.a;			gl_FragColor = vec4(ct * cf, at * af);	}	else	{				// find common info: unit size		float nx = 1.0 / NumTiles;		float ny = nx * scRatio;		vec2 size = vec2(nx, ny);   		vec2 Pbase = gl_TexCoord[0].st - mod(gl_TexCoord[0].st, size);   		vec2 PCenter = Pbase + (size * 0.5);	    	if (tileMode == 0)    	{    		// mosaic tile    		vec2 st = (gl_TexCoord[0].st - Pbase) / size;    		vec4 c1 = vec4(0.0);    		vec4 c2 = vec4(0.0);    		vec4 invOff = vec4((vec3(1)-EdgeColor),1);        		if (st.x > st.y) { c1 = invOff; }        		float threshholdB =  1.0 - Threshhold;        		if (st.x > threshholdB) { c2 = c1; }    		if (st.y > threshholdB) { c2 = c1; }    		vec4 cBottom = c2;        		c1 = vec4(0.0);    		c2 = vec4(0.0);        		if (st.x > st.y) { c1 = invOff; }    		if (st.x < Threshhold) { c2 = c1; }    		if (st.y < Threshhold) { c2 = c1; }    		vec4 cTop = c2;        		// brute force...: use center color    		vec4 tileColor = texture2D(rttMap, PCenter);        		gl_FragColor = tileColor + cTop - cBottom;        	}    	else if (tileMode == 1)    	{    		// mirrored tile: duplicate image around all tile unit    		vec2 cd = gl_TexCoord[0].st * NumTiles / 8.0;    		gl_FragColor = texture2D(rttMap, cd);    		    		cd = fract(cd);    		if ( any(lessThan(cd, vec2(0.01, 0.01))) ||     	 	 	 any( greaterThan(cd, vec2(0.99, 0.99)))  )    			gl_FragColor = vec4(0.5);     	}        	if ( any(lessThan(gl_TexCoord[0].st, vec2(0.001, 0.001))) ||     	 	 any( greaterThan(gl_TexCoord[0].st, vec2(0.999, 0.999)))  )    		gl_FragColor = vec4(1.0);    	    }}